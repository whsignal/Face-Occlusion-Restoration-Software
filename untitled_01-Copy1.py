# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'untitled.ui'
#
# Created by: PyQt5 UI code generator 5.15.9
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

import sys
import os
import datetime
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtWidgets import QFileDialog, QColorDialog, QMessageBox
from PyQt5.QtGui import QPixmap, QPainter, QPen, QColor, QBrush, QImage
from PyQt5.QtCore import Qt, QPoint, QSize
import random
import cv2
import numpy as np

from tempt_plusplus import generate_random_shape_with_percentage
from inference_inpainting import run_inference


# 获取当前脚本的绝对路径
current_file = os.path.abspath(__file__)
# 获取项目根目录的绝对路径
root_dir = os.path.dirname(os.path.dirname(os.path.dirname(current_file)))
# 将项目根目录添加到Python路径中
sys.path.append(root_dir)
# 从项目根目录下的模块导入ImageGenerator
import codeformer.MAT
from codeformer.MAT.generate_image import ImageGenerator

# from PyQt5 import QtCore, QtGui, QtWidgets

#待完成：画笔粗细选择、随机破损

#不能连续绘制。

# untitled_01
# 实时更新破损比例。--非常卡
# 正方形画笔
# 完成手动、均匀(随机)破损
# ！！！！！注意半径为1的圆形面积为3.14，和矩形不一样

# untitled_02
# 每次绘制完成后更新比例--流畅
# 正方形画笔

# untitled_03
# 每次绘制完成后更新比例--流畅
# 圆形画笔--非常卡非常卡


# 未解决的问题
# 1、图片缩放带来的鼠标与画笔位置偏差的问题。 -------部分OK
# 2、布局略微有点偏小的问题 -------OK
# 3、所有部件没有特殊命名的小问题 -------OK
# 4、实时更新比例会导致运行非常慢 --------暂时OK不了
# 5、恢复原图
# 6、保存/导出

# 定义全局变量
WHITE_MASKED_PATH = None
BLACK_MASKED_PATH = None
FILE_WHITE = None
FILE_MAT = None


class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(1332, 890)
        MainWindow.setMinimumSize(QtCore.QSize(5, 10))
        font = QtGui.QFont()
        font.setFamily("Arial")
        font.setPointSize(14)
        MainWindow.setFont(font)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.layoutWidget = QtWidgets.QWidget(self.centralwidget)
        self.layoutWidget.setGeometry(QtCore.QRect(60, 760, 751, 47))
        self.layoutWidget.setObjectName("layoutWidget")
        self.horizontalLayout_5 = QtWidgets.QHBoxLayout(self.layoutWidget)
        self.horizontalLayout_5.setContentsMargins(0, 0, 0, 0)
        self.horizontalLayout_5.setObjectName("horizontalLayout_5")
        self.SelectPicture = QtWidgets.QPushButton(self.layoutWidget)
        self.SelectPicture.setMinimumSize(QtCore.QSize(0, 45))
        font = QtGui.QFont()
        font.setFamily("Arial")
        font.setPointSize(14)
        self.SelectPicture.setFont(font)
        self.SelectPicture.setObjectName("SelectPicture")
        self.horizontalLayout_5.addWidget(self.SelectPicture)
        spacerItem = QtWidgets.QSpacerItem(70, 20, QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_5.addItem(spacerItem)
        self.DoOperate = QtWidgets.QPushButton(self.layoutWidget)
        self.DoOperate.setMinimumSize(QtCore.QSize(0, 45))
        font = QtGui.QFont()
        font.setFamily("Arial")
        font.setPointSize(16)
        self.DoOperate.setFont(font)
        self.DoOperate.setObjectName("DoOperate")
        self.horizontalLayout_5.addWidget(self.DoOperate)
        self.SystemName = QtWidgets.QLabel(self.centralwidget)
        self.SystemName.setGeometry(QtCore.QRect(381, 25, 751, 51))
        font = QtGui.QFont()
        font.setFamily("Arial")
        font.setPointSize(24)
        self.SystemName.setFont(font)
        self.SystemName.setTextFormat(QtCore.Qt.PlainText)
        self.SystemName.setObjectName("SystemName")
        self.label = QtWidgets.QLabel(self.centralwidget)
        self.label.setGeometry(QtCore.QRect(80, 95, 512, 512))
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.label.sizePolicy().hasHeightForWidth())
        self.label.setSizePolicy(sizePolicy)
        self.label.setMinimumSize(QtCore.QSize(512, 512))
        self.label.setMaximumSize(QtCore.QSize(512, 512))
        self.label.setObjectName("label")
        self.picture_after = QtWidgets.QLabel(self.centralwidget)
        self.picture_after.setGeometry(QtCore.QRect(740, 95, 512, 512))
        self.picture_after.setMinimumSize(QtCore.QSize(512, 512))
        self.picture_after.setMaximumSize(QtCore.QSize(400, 550))
        self.picture_after.setObjectName("picture_after")
        self.layoutWidget1 = QtWidgets.QWidget(self.centralwidget)
        self.layoutWidget1.setGeometry(QtCore.QRect(60, 640, 381, 101))
        self.layoutWidget1.setObjectName("layoutWidget1")
        self.verticalLayout_3 = QtWidgets.QVBoxLayout(self.layoutWidget1)
        self.verticalLayout_3.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_3.setObjectName("verticalLayout_3")
        self.horizontalLayout_6 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_6.setObjectName("horizontalLayout_6")
        self.horizontalSlider_random = QtWidgets.QSlider(self.layoutWidget1)
        self.horizontalSlider_random.setMinimumSize(QtCore.QSize(250, 35))
        self.horizontalSlider_random.setMaximumSize(QtCore.QSize(200, 16777215))
        self.horizontalSlider_random.setOrientation(QtCore.Qt.Horizontal)
        self.horizontalSlider_random.setObjectName("horizontalSlider_random")
        self.horizontalLayout_6.addWidget(self.horizontalSlider_random)
        self.random_percent = QtWidgets.QTextEdit(self.layoutWidget1)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Minimum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.random_percent.sizePolicy().hasHeightForWidth())
        self.random_percent.setSizePolicy(sizePolicy)
        self.random_percent.setMinimumSize(QtCore.QSize(100, 5))
        self.random_percent.setMaximumSize(QtCore.QSize(100, 20))
        self.random_percent.setObjectName("random_percent")
        self.horizontalLayout_6.addWidget(self.random_percent)
        self.label_11 = QtWidgets.QLabel(self.layoutWidget1)
        self.label_11.setMaximumSize(QtCore.QSize(15, 16777215))
        self.label_11.setObjectName("label_11")
        self.horizontalLayout_6.addWidget(self.label_11)
        self.verticalLayout_3.addLayout(self.horizontalLayout_6)
        self.pushButton_random = QtWidgets.QPushButton(self.layoutWidget1)
        self.pushButton_random.setEnabled(True)
        self.pushButton_random.setMinimumSize(QtCore.QSize(297, 45))
        self.pushButton_random.setMaximumSize(QtCore.QSize(349, 16777215))
        font = QtGui.QFont()
        font.setFamily("Arial")
        font.setPointSize(14)
        self.pushButton_random.setFont(font)
        self.pushButton_random.setObjectName("pushButton_random")
        self.verticalLayout_3.addWidget(self.pushButton_random)
        self.layoutWidget2 = QtWidgets.QWidget(self.centralwidget)
        self.layoutWidget2.setGeometry(QtCore.QRect(460, 640, 381, 101))
        self.layoutWidget2.setObjectName("layoutWidget2")
        self.verticalLayout_2 = QtWidgets.QVBoxLayout(self.layoutWidget2)
        self.verticalLayout_2.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_2.setObjectName("verticalLayout_2")
        self.horizontalLayout_4 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_4.setObjectName("horizontalLayout_4")
        self.horizontalSlider_draw = QtWidgets.QSlider(self.layoutWidget2)
        self.horizontalSlider_draw.setMinimumSize(QtCore.QSize(250, 35))
        self.horizontalSlider_draw.setMaximumSize(QtCore.QSize(250, 16777215))
        self.horizontalSlider_draw.setOrientation(QtCore.Qt.Horizontal)
        self.horizontalSlider_draw.setObjectName("horizontalSlider_draw")
        self.horizontalLayout_4.addWidget(self.horizontalSlider_draw)
        self.draw_percent = QtWidgets.QTextEdit(self.layoutWidget2)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Minimum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.draw_percent.sizePolicy().hasHeightForWidth())
        self.draw_percent.setSizePolicy(sizePolicy)
        self.draw_percent.setMinimumSize(QtCore.QSize(100, 5))
        self.draw_percent.setMaximumSize(QtCore.QSize(100, 20))
        self.draw_percent.setObjectName("draw_percent")
        self.horizontalLayout_4.addWidget(self.draw_percent)
        self.label_8 = QtWidgets.QLabel(self.layoutWidget2)
        self.label_8.setMaximumSize(QtCore.QSize(15, 16777215))
        self.label_8.setObjectName("label_8")
        self.horizontalLayout_4.addWidget(self.label_8)
        self.verticalLayout_2.addLayout(self.horizontalLayout_4)
        self.pushButton_draw = QtWidgets.QPushButton(self.layoutWidget2)
        self.pushButton_draw.setMinimumSize(QtCore.QSize(350, 45))
        self.pushButton_draw.setMaximumSize(QtCore.QSize(320, 16777215))
        font = QtGui.QFont()
        font.setFamily("Arial")
        font.setPointSize(14)
        self.pushButton_draw.setFont(font)
        self.pushButton_draw.setObjectName("pushButton_draw")
        self.verticalLayout_2.addWidget(self.pushButton_draw)
        self.ExportImage = QtWidgets.QPushButton(self.centralwidget)
        self.ExportImage.setGeometry(QtCore.QRect(1100, 700, 180, 50))
        self.ExportImage.setObjectName("ExportImage")
        self.CFfunc = QtWidgets.QPushButton(self.centralwidget)
        self.CFfunc.setGeometry(QtCore.QRect(890, 640, 180, 50))
        self.CFfunc.setObjectName("CFfunc")
        self.MATfunc = QtWidgets.QPushButton(self.centralwidget)
        self.MATfunc.setGeometry(QtCore.QRect(1100, 640, 180, 50))
        self.MATfunc.setObjectName("MATfunc")
        self.ADDfunc = QtWidgets.QPushButton(self.centralwidget)
        self.ADDfunc.setGeometry(QtCore.QRect(890, 700, 180, 50))
        self.ADDfunc.setObjectName("ADDfunc")
        self.label_2 = QtWidgets.QLabel(self.centralwidget)
        self.label_2.setGeometry(QtCore.QRect(895, 765, 321, 16))
        self.label_2.setObjectName("label_2")
        self.label_3 = QtWidgets.QLabel(self.centralwidget)
        self.label_3.setGeometry(QtCore.QRect(895, 790, 391, 16))
        self.label_3.setObjectName("label_3")
        MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 1332, 28))
        self.menubar.setObjectName("menubar")
        MainWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)

        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "MainWindow"))
        self.SelectPicture.setText(_translate("MainWindow", "Select"))
        self.DoOperate.setText(_translate("MainWindow", "Tackle"))
        self.SystemName.setText(_translate("MainWindow", "Damaged Image Restoration System"))
        self.label.setText(_translate("MainWindow", "image_Origin"))
        self.picture_after.setText(_translate("MainWindow", "image_After"))
        self.label_11.setText(_translate("MainWindow", "%"))
        self.pushButton_random.setText(_translate("MainWindow", "Random Damage --->"))
        self.label_8.setText(_translate("MainWindow", "%"))
        self.pushButton_draw.setText(_translate("MainWindow", "Draw Damage --->"))
        self.ExportImage.setText(_translate("MainWindow", "Export"))
        self.CFfunc.setText(_translate("MainWindow", "CodeFormer"))
        self.MATfunc.setText(_translate("MainWindow", "MAT"))
        self.ADDfunc.setText(_translate("MainWindow", "Superposition"))
        self.label_2.setText(_translate("MainWindow", "Results Directory: "))
        self.label_3.setText(_translate("MainWindow", "root/codeformer/CodeFormer/sample"))





class MainWindow(QtWidgets.QMainWindow):
    def __init__(self):
        super().__init__()
        self.ui = Ui_MainWindow()
        self.ui.setupUi(self)

        # 绑定按钮点击事件
        self.ui.SelectPicture.clicked.connect(self.import_image)  # 导入图片
        self.ui.pushButton_draw.clicked.connect(self.start_drawing)  # 开始涂鸦
        self.ui.pushButton_random.clicked.connect(self.random_damage)  # 随机破损
        self.ui.horizontalSlider_random.valueChanged.connect(self.update_random_percent)   # 绑定滑块值变化事件
        self.ui.ExportImage.clicked.connect(self.export_image)  # 导出
        self.ui.DoOperate.clicked.connect(self.on_do_operate_clicked)     #处理按键-默认CodeFormer
        self.ui.MATfunc.clicked.connect(self.on_matfunc_clicked)          #MAT处理
        self.ui.CFfunc.clicked.connect(self.on_cffunc_clicked)          #MAT处理

        # 初始化变量
        self.pixmap = None  # 用于存储原始图片
        self.drawing = False  # 标记是否处于涂鸦模式
        self.last_point = QPoint()  # 记录上一个鼠标位置
        self.drawing_pixmap = None  # 用于记录涂鸦的 QPixmap

        # QLabel 的固定大小
        self.ui.label.setScaledContents(True)  # 确保图片自动缩放以适应 QLabel

    def import_image(self):
        """导入图片并显示在 QLabel 中"""
        self.file_path, _ = QFileDialog.getOpenFileName(self, "选择图片", "", "Image Files (*.png *.jpg *.bmp *.gif)")
        if self.file_path:
            self.pixmap = QPixmap(self.file_path)

            # 确保图片自动适应 QLabel 的大小
            self.pixmap = self.pixmap.scaled(self.ui.label.size(), Qt.KeepAspectRatio, Qt.SmoothTransformation)

            self.drawing_pixmap = QPixmap(self.pixmap.size())  # 创建一个与图片大小相同的 QPixmap 用于记录涂鸦
            self.drawing_pixmap.fill(Qt.transparent)  # 初始化为透明
            self.ui.label.setPixmap(self.pixmap)  # 显示图片

    def start_drawing(self):
        """激活涂鸦模式"""
        self.drawing = True
        self.ui.label.setCursor(Qt.CrossCursor)  # 设置鼠标为十字光标

    def map_to_pixmap(self, label_pos):
        """将 QLabel 的坐标转换为 QPixmap 的坐标"""
        if self.pixmap:
            label_rect = self.ui.label.rect()  # 获取 QLabel 的矩形区域
            pixmap_rect = self.pixmap.rect()  # 获取 QPixmap 的矩形区域

            # 计算缩放比例
            scale_factor_x = pixmap_rect.width() / label_rect.width()
            scale_factor_y = pixmap_rect.height() / label_rect.height()

            # 转换坐标
            x = label_pos.x() * scale_factor_x
            y = label_pos.y() * scale_factor_y

            return QPoint(int(x), int(y))  # 返回转换后的坐标
        return QPoint()

    def random_damage(self):
        """根据滑块的比例对图片进行随机破损"""
        
        if self.pixmap:
            damage_ratio = self.ui.horizontalSlider_random.value() / 100.0  # 获取滑块的比例值
    
            # 将QPixmap转换为OpenCV的numpy格式
            qimg = self.pixmap.toImage()
            buffer = qimg.bits().asarray(qimg.byteCount())
            cv_image = np.array(buffer).reshape(qimg.height(), qimg.width(), 4)  # 4通道：RGBA
    
            # 转换为BGR格式（如果需要）
            cv_image = cv2.cvtColor(cv_image, cv2.COLOR_BGRA2BGR)
    
            # 调用generate_random_shape_with_percentage函数
            damaged_image = generate_random_shape_with_percentage(cv_image, target_percentage=damage_ratio * 100)
            
            # 将OpenCV的BGR格式转换回RGB格式，以便正确显示
            damaged_image = cv2.cvtColor(damaged_image, cv2.COLOR_BGR2RGB)
    
            # 将OpenCV的numpy格式转换回QImage
            height, width, channel = damaged_image.shape
            bytes_per_line = 3 * width
            qimg_damaged = QImage(damaged_image.data, width, height, bytes_per_line, QImage.Format_RGB888)
    
            # 创建一个新的QPixmap来显示破损后的图片
            damaged_pixmap = QPixmap.fromImage(qimg_damaged)
    
            # 更新显示的图片
            combined_pixmap = QPixmap(self.pixmap.size())  # 创建一个与原始图片大小相同的QPixmap
            combined_pixmap.fill(Qt.transparent)  # 初始化为透明
            painter = QPainter(combined_pixmap)
            painter.drawPixmap(0, 0, self.pixmap)  # 绘制原始图片
            painter.drawPixmap(0, 0, damaged_pixmap)  # 绘制破损效果
            painter.end()
            self.ui.label.setPixmap(combined_pixmap)  # 更新QLabel的图片

    def update_random_percent(self, value):
        """更新随机破损比例的显示"""
        self.ui.random_percent.setPlainText(f"{value}")  # 将滑块的值显示在 QTextEdit 中

    def mousePressEvent(self, event):
        """鼠标按下事件"""
        if self.drawing and event.button() == Qt.LeftButton:
            # 获取鼠标相对于 QLabel 的位置
            pos = self.ui.label.mapFromParent(event.pos())
            # 将 QLabel 的坐标转换为 QPixmap 的坐标
            self.last_point = self.map_to_pixmap(pos)

    def mouseMoveEvent(self, event):
        """鼠标移动事件"""
        if self.drawing:
            # 获取鼠标相对于 QLabel 的位置
            pos = self.ui.label.mapFromParent(event.pos())
            # 将 QLabel 的坐标转换为 QPixmap 的坐标
            current_point = self.map_to_pixmap(pos)

            # 创建 QPainter 对象用于在 drawing_pixmap 上绘制
            painter = QPainter(self.drawing_pixmap)
            painter.setPen(QPen(Qt.white, 20, Qt.SolidLine))  # 设置画笔颜色、大小和样式
            painter.drawLine(self.last_point, current_point)  # 绘制线条
            painter.end()

            # 更新显示的图片
            combined_pixmap = QPixmap(self.pixmap.size())  # 创建一个与原始图片大小相同的 QPixmap
            combined_pixmap.fill(Qt.transparent)  # 初始化为透明
            painter = QPainter(combined_pixmap)
            painter.drawPixmap(0, 0, self.pixmap)  # 绘制原始图片
            painter.drawPixmap(0, 0, self.drawing_pixmap)  # 绘制涂鸦
            painter.end()
            self.ui.label.setPixmap(combined_pixmap)  # 更新 QLabel 的图片

            # 更新破损比例
            self.update_drawing_ratio()

            self.last_point = current_point  # 更新上一个鼠标位置

    def mouseReleaseEvent(self, event):
        """鼠标释放事件"""
        if self.drawing and event.button() == Qt.LeftButton:
            self.drawing = False
            self.ui.label.setCursor(Qt.ArrowCursor)  # 恢复默认光标

    def update_drawing_ratio(self):
        """实时更新涂鸦占图片的比例"""
        if self.drawing_pixmap:
            drawing_image = self.drawing_pixmap.toImage()  # 将 QPixmap 转换为 QImage
            total_pixels = drawing_image.width() * drawing_image.height()  # 图片的总像素数
            white_pixels = 0  # 记录白色像素的数量

            # 遍历图片的每个像素
            for x in range(drawing_image.width()):
                for y in range(drawing_image.height()):
                    if drawing_image.pixelColor(x, y) == QColor(255, 255, 255, 255):
                        white_pixels += 1

            # 计算涂鸦比例
            ratio = (white_pixels / total_pixels) * 100
            self.ui.horizontalSlider_draw.setValue(int(ratio))  # 更新滑块的值
            self.ui.draw_percent.setText(f"{ratio:.2f}%")  # 更新文本框的值


    def closeEvent(self, event):
        """关闭窗口时停止涂鸦"""
        self.drawing = False

    def export_image(self):
        """将绘制后的图像导出为文件"""
        global BLACK_MASKED_PATH  # 声明使用全局变量
        global WHITE_MASKED_PATH  # 声明使用全局变量
        if self.pixmap and self.drawing_pixmap:
            # 创建一个与原始图片大小相同的 QPixmap 用于保存最终图像
            final_pixmap_white = QPixmap(self.pixmap.size())  # 用于白色涂鸦
            final_pixmap_black = QPixmap(self.pixmap.size())  # 用于黑色涂鸦
            final_pixmap_white.fill(Qt.transparent)
            final_pixmap_black.fill(Qt.transparent)

            # 合并原始图片和白色涂鸦图层
            painter_white = QPainter(final_pixmap_white)
            painter_white.drawPixmap(0, 0, self.pixmap)  # 绘制原始图片
            painter_white.drawPixmap(0, 0, self.drawing_pixmap)  # 绘制白色涂鸦
            painter_white.end()

            # 创建一个黑色涂鸦图层
            self.drawing_pixmap_black = self.drawing_pixmap.copy()
            painter_black = QPainter(self.drawing_pixmap_black)
            # 遍历每个像素，将白色涂鸦变为黑色
            for x in range(self.drawing_pixmap_black.width()):
                for y in range(self.drawing_pixmap_black.height()):
                    color = self.drawing_pixmap_black.toImage().pixelColor(x, y)
                    if color == Qt.white:  # 如果是白色涂鸦
                        painter_black.setPen(Qt.black)  # 设置为黑色
                        painter_black.drawPoint(x, y)
            painter_black.end()

            # 合并原始图片和黑色涂鸦图层
            painter_black_final = QPainter(final_pixmap_black)
            painter_black_final.drawPixmap(0, 0, self.pixmap)  # 绘制原始图片
            painter_black_final.drawPixmap(0, 0, self.drawing_pixmap_black)  # 绘制黑色涂鸦
            painter_black_final.end()

            # 调整大小到512x512
            if final_pixmap_white.size() != (512, 512):
                final_pixmap_white = final_pixmap_white.scaled(512, 512, Qt.IgnoreAspectRatio, Qt.SmoothTransformation)
                final_pixmap_black = final_pixmap_black.scaled(512, 512, Qt.IgnoreAspectRatio, Qt.SmoothTransformation)

            # 获取上级目录路径
            parent_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
            result_masked_dir = os.path.join(parent_dir, "result", "masked")

            # 创建目录用于保存两种涂鸦效果
            white_dir = os.path.join(result_masked_dir, "white")
            black_dir = os.path.join(result_masked_dir, "black")
            os.makedirs(white_dir, exist_ok=True)
            os.makedirs(black_dir, exist_ok=True)

            # 使用时间戳生成唯一的文件名
            timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
            white_file_name = f"{timestamp}_white.png"
            black_file_name = f"{timestamp}_black.png"

            # 保存白色涂鸦版本
            white_file_path = os.path.join(white_dir, white_file_name)
            final_pixmap_white.save(white_file_path, "PNG", 100)
            WHITE_MASKED_PATH = white_file_path  # 更新全局变量
            print(f"白色涂鸦图像已保存到: {WHITE_MASKED_PATH}")

            # 保存黑色涂鸦版本
            black_file_path = os.path.join(black_dir, black_file_name)
            final_pixmap_black.save(black_file_path, "PNG", 100)
            BLACK_MASKED_PATH = black_file_path  # 更新全局变量
            print(f"黑色涂鸦图像已保存到: {BLACK_MASKED_PATH}")


    def on_do_operate_clicked(self):
        #按键测试
        # self.show_dialog("按钮点击测试", "按键已被点击！")        
        # 获取 self.ui.label 中的图片并转换为 QImage
        pixmap = self.ui.label.pixmap()
        image = pixmap.toImage()

        # 保存图片到临时文件
        temp_image_path = "temp_image.png"
        image.save(temp_image_path, "PNG")

        # 调用 run_inference 函数处理图片
        run_inference(input_path=temp_image_path, output_path=None, suffix=None)

        # 假设处理后的图片保存在 outputs/processed_image.png
        processed_image_path = "results/test_inpainting_img/temp_image.png"

        # 将处理后的图片显示在 self.ui.label 中
        processed_pixmap = QPixmap(processed_image_path)
        self.ui.picture_after.setPixmap(processed_pixmap)
        
        
    def show_dialog(self, title, message):
        # 创建并显示一个信息对话框
        QMessageBox.information(self, title, message)
        
        
    def on_cffunc_clicked(self):
        # 按键测试
        # self.show_dialog("按钮点击测试", "按键已被点击！")   
        self.export_image()
             
        global WHITE_MASKED_PATH  # 声明使用全局变量
        global FILE_WHITE
    
        print(f"当前的WHITE_MASKED_PATH: {WHITE_MASKED_PATH}")  # 打印WHITE_MASKED_PATH
        
        if WHITE_MASKED_PATH is not None:
            # 调用 run_inference 函数处理图片
            run_inference(input_path=WHITE_MASKED_PATH, output_path=None, suffix=None)
    
            # 假设处理后的图片保存在 results/test_inpainting_img/ 目录下，文件名保持不变
            # 获取WHITE_MASKED_PATH的文件名
            file_name = os.path.basename(WHITE_MASKED_PATH)
            processed_image_path = f"results/test_inpainting_img/{file_name}"
            FILE_WHITE = processed_image_path
    
            # 将处理后的图片显示在 self.ui.picture_after 中
            processed_pixmap = QPixmap(processed_image_path)
            self.ui.picture_after.setPixmap(processed_pixmap)
        else:
            print("没有找到白色涂鸦图像，请先保存白色涂鸦图像。")
        
        
    def on_matfunc_clicked(self):
        """处理MATfunc按钮点击事件"""
        self.export_image()
        
        global BLACK_MASKED_PATH
        global FILE_MAT
        
        print(f"当前的BLACK_MASKED_PATH: {BLACK_MASKED_PATH}")  # 打印BLACK_MASKED_PATH
        if BLACK_MASKED_PATH is not None:
          # 初始化生成器
          generator = ImageGenerator(
              network_pkl='pretrained/CelebA-HQ_512.pkl',
              resolution=512,
              truncation_psi=1.0,
              noise_mode='const'
          )
  
          # 从BLACK_MASKED_PATH中读取图片
          image_paths = [BLACK_MASKED_PATH]
          mask_paths = None  # 如果没有特定的mask路径，可以设置为None
          output_dir = 'samples'
    
          # 调用generator的generate_images方法
          generator.generate_images(
                image_paths=image_paths,
                mask_paths=mask_paths,
                output_dir=output_dir
          )
          print(f"图像处理完成，结果保存在: {output_dir}")
          # 假设处理后的图片保存在 output_dir 中，文件名保持不变
          # 获取BLACK_MASKED_PATH的文件名
          file_name = os.path.basename(BLACK_MASKED_PATH)
          processed_image_path = os.path.join(output_dir, file_name)
          FILE_MAT = processed_image_path
  
          # 将处理后的图片显示在 self.ui.picture_after 中
          processed_pixmap = QPixmap(processed_image_path)
          self.ui.picture_after.setPixmap(processed_pixmap)
        else:
          print("没有找到黑色涂鸦图像，请先保存黑色涂鸦图像。")

    def blend_images(self):
        global FILE_WHITE
        global FILE_BLACK
        # 支持的图像扩展名
        valid_exts = ('.png', '.jpg', '.jpeg', '.bmp')
        # 检查文件扩展名
        if not (FILE_WHITE.lower().endswith(valid_exts) and FILE_MAT.lower().endswith(valid_exts)):
            print("文件格式不支持！")
            return
        # 读取图像
        img_white = cv2.imread(FILE_WHITE)
        img_mat = cv2.imread(FILE_MAT)

        if img_white is None or img_mat is None:
            print(f"读取失败：{FILE_WHITE} 或 {FILE_MAT}")
            return

        # 若图像大小不同，统一为white图像大小
        if img_white.shape != img_mat.shape:
            img_mat = cv2.resize(img_mat, (img_white.shape[1], img_white.shape[0]))

        # 图像叠加
        blended = cv2.addWeighted(img_white, 0.5, img_mat, 0.5, 0)

        # 保存结果
        output_filename = os.path.basename(FILE_WHITE)
        output_path = os.path.join(OUTPUT_FOLDER, output_filename)
        cv2.imwrite(output_path, blended)
        print(f"保存叠加图像: {output_path}")

        # 显示结果到界面
        pixmap = QPixmap(output_path)
        self.ui.setPixmap(pixmap)
        self.ui.setAlignment(Qt.AlignCenter)
        



if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    window = MainWindow()
    window.show()
    sys.exit(app.exec_())